[{"title":"CasperJS 技术笔记","date":"2017-02-03T05:28:58.000Z","path":"2017/02/03/CasperJS/","text":"爬虫 &amp;&amp; 前端页面自动化检测 在日常开发中，项目过于庞大，比如修改某个变量（例如 LESS），就可能会引起其他页面的显示异常 如果交给测试的伙伴进行测试也比较耗时，所以利用自动化检测工具让开发人员写好测试脚本进行自测，可以提高排错效率，有可以及时发现问题。 缺点就是脚本需要开发人员自己写…，可能会加大开发成本。 PhantomJS 可以模拟浏览器（V8引擎），发出一些请求或者模拟用户实现事件操作。 CasperJS 是对 PhantomJS 的封装，API 更加简洁。 有了模拟浏览器的功能可以实现前端页面自动化测试与爬虫统计。 通过自动填写表单，发出登陆请求，可以进行爬虫。 安装官方文档：http://casperjs.org/ github 上 clone 就好了 Casper/bin 添加到环境变量 依赖 ruby，记得提前安装 需要考虑的问题 如何进行自动化测试 对于异步请求如何获取动态创建的 DOM 元素 关于集成 实例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465console.log('');var casper = require('casper').create(&#123; onWaitTimeout: function () &#123; // 页面无响应保存截图 var timestamp = new Date().getTime(); this.capture(timestamp + \".png\"); this.echo('ERROR：以上操作，网速延迟或加载错误，快照保存至。' + timestamp + '.jpg'); &#125;, logLevel: 'debug'&#125;);// 超时等待时间casper.options.waitTimeout = 15000;// 输出浏览器控制台错误casper.on('page.error', function (msg) &#123; this.echo('浏览器控制台错误信息: ' + msg);&#125;);// 监听页面 404casper.on('http.status.404', function(resource) &#123; this.log('Hey, this one is 404: ' + resource.url, 'warning');&#125;);// 监听页面 500casper.on('http.status.500', function(resource) &#123; this.log('Hey, this one is 404: ' + resource.url, 'warning');&#125;);// http://XXXXXX/casper.start('http://XXXXXX/');// 结构跳转测试casper.then(function (response) &#123; this.echo('http://XXXXXX/ 页面测试开始...'); if (response.url === 'http://XXXXXX/') &#123; this.echo('页面跳转 OK '); &#125; else &#123; this.echo('ERROR：页面跳转错误'); // self.stop(); &#125;&#125;);// 结构测试casper.then(function (response) &#123; if (this.exists('a[class=\"weui-btn weui-btn_primary\"]')) &#123; this.echo('结构测试 OK'); &#125; else &#123; this.echo('ERROR：结构测试错误'); &#125;&#125;);// 交互测试casper.thenClick('.vote-info i',function () &#123; /*this.waitForSelector('#div[style=\"color: green;\"]', function () &#123; this.echo('ajax: ' + this.getTitle()); this.echo(this.getHTML('#div', true)); // 获取 HTML 样式 &#125;, function onTimeout() &#123; this.echo('wait selector timeout') &#125;, timeout = 15000);*/&#125;);casper.run(); 获取 DOM123456function getLinks() &#123; var links = document.querySelectorAll('h3.r a'); return Array.prototype.map.call(links, function(e) &#123; return e.getAttribute('href'); &#125;);&#125; 在外面操作不到 DOM 元素的，必须使用 evaluate 123this.evaluate(function () &#123; document.querySelectorAll('#div')[0].setAttribute('name', 'haha');&#125;); 需要注意的地方1）create casper的时候，我们inject了jquery，这个jquery必须是保存在本地的，通过HTTP访问是无效的。 2）this.evaluate(getTitles)可以理解成，我们在CasperJs中，将getTitles这个方法注入到了访问的页面中，在访问的页面中执行这个方法并反问其返回值。 3）访问页面log的获取 1234567casper.then(function() &#123; this.page.onConsoleMessage = function(e) &#123; console.log(e); &#125; search_result_titles = this.evaluate(getTitles) this.echo(search_result_titles.join('\\n'))&#125;) 这样就可以侦听被访问页面的console.log事件，比导出到CasperJs中","tags":[{"name":"前端页面自动化测试","slug":"前端页面自动化测试","permalink":"http://yoursite.com/tags/前端页面自动化测试/"}]},{"title":"PhantomJS","date":"2017-01-11T16:08:58.000Z","path":"2017/01/12/PhantomJS/","text":"近期老大分配任务，让我们写页面时，完成自动化测试，防止跨页面异常，总结了些技术点。 Phantom JS 是一个服务器端的 JavaScript API 的 WebKithttp://imweb.io/topic/560b402ac2317a8c3e08621c 配置环境变量即可 phantomjs hello.js 运行 代码案例12console.log('Hello, world!');phantom.exit(); // 否则 PhantomJS 将根本不会停止 传递参数 123456789var system = require(&apos;system&apos;);if (system.args.length === 1) &#123; console.log(&apos;length error&apos;);&#125; else &#123; system.args.forEach(function (arg, i) &#123; console.log(i+ &apos;: &apos; + arg); &#125;);&#125;phantom.exit(); 网页截图 1234567var page = require('webpage').create();page.open('http://www.baidu.com', function () &#123;page.viewportSize=&#123;width:500,height:968&#125;; // 指定图片大小// page.clipRect = &#123; top: 0, left: 0, width: 600, height: 700 &#125;; // 指定图片大小page.render('example.jpg');phantom.exit();&#125;); 计算页面加载时间 1234567891011121314151617181920212223\"use strict\";var page = require('webpage').create(), system = require('system'), t, address;if (system.args.length === 1) &#123; console.log('Usage: loadspeed.js &lt;some URL&gt;'); phantom.exit(1);&#125; else &#123; t = Date.now(); address = system.args[1]; page.open(address, function (status) &#123; if (status !== 'success') &#123; console.log('FAIL to load the address'); &#125; else &#123; t = Date.now() - t; console.log('Page title is ' + page.evaluate(function () &#123; return document.title; &#125;)); console.log('Loading time ' + t + ' msec'); &#125; phantom.exit(); &#125;);&#125; $ phantomjs loadspeed.js http://www.baidu.com 输出的信息为 网页加载时间 代码运算（获取页面 DOM） var page = require('webpage').create();123456789101112131415var url = 'http://localhost:9999/';// 在 evaluate 不能运行 console 的方法，需要给 onConsoleMessage 添加函数对象// 然后就可以在 evaluate 使用 console 了page.onConsoleMessage = function (msg) &#123; console.log(msg);&#125;;page.open(url, function (status) &#123; if(status === 'success')&#123; var divTxt = page.evaluate(function () &#123; console.log(111); return document.querySelectorAll('div')[0].innerText; &#125;); console.log(divTxt); &#125;&#125;); 使用 evaluate() 方法，在此回调函数内，可以操作 dom。 代码是在“沙箱”中运行的，它没有办法读取在其所属页面上下文之外的任何JavaScript对象和变量。 evaluate() 会返回一个对象，然而它仅限制于简单的对象并且不能包含方法或闭包。 onConsoleMessage // 可以在 evaluate 中使用 console page.settings page.settings.userAgent // 获取浏览器版本 page.settings.userAgent = &#39;SpecialAgent&#39;; // 设置浏览器版本，模拟不同浏览器 结合 JQ 测试 123456789101112var page = require('webpage').create();page.onConsoleMessage = function (msg) &#123; console.log(msg);&#125;;page.open('http://localhost:9999/', function() &#123; page.includeJs(\"http://cdn.bootcss.com/jquery/2.2.4/jquery.js\", function() &#123; page.evaluate(function() &#123; console.log($(\"#id\").text()); &#125;); phantom.exit() &#125;);&#125;); 注意，由于includeJs是异步加载脚本，所以phantom.exit()需要放在page.includeJs()的回调函数中，否则phantomjs进程会过早退出。 模拟登陆12345678910var webPage = require('webpage');var page = webPage.create(); page.includeJs('http://code.jquery.com/jquery-1.10.2.min.js', function() &#123; // 模拟登录 var $testForm = $('form#login'); $testForm.find('input[name=\"username\"]').value('barret'); $testForm.find('input[name=\"password\"]').value('1234'); $testForm.submit();&#125;); 用于获取 请求头、响应头 123456789 var page = require('webpage').create();page.onResourceRequested = function (request) &#123; console.log('Request ' + JSON.stringify(request, undefined, 4));&#125;;page.onResourceReceived = function (response) &#123; console.log('Receive ' + JSON.stringify(response, undefined, 4));&#125;;page.open('http://localhost:9999/'); 可以使用 JSON 工具对象 输出编码 phantom.outputEncoding=&quot;gbk&quot;; // 无效 在 phantom 中 window 与 浏览器一致 12console.log(window === this);phantom.exit(); 发起 POST 请求1234567var webPage = require(\"webpage\");var page = webPage.create();var postBody = \"user=username&amp;password=password\";page.open(\"http://www.google.com/\", \"POST\", postBody, function(status) &#123; console.log(\"Status: \" + status); // Do other things here...&#125;); 注入参数12345678page.open('https://item.taobao.com/item.htm?id=520115087331', function(status) &#123; var domId = \"J_SellCounter\" var sellCounter = page.evaluate(function(id) &#123; return document.getElementById(id).innerText; &#125;, domId); console.log(sellCounter); phantom.exit();&#125;); 图片处理123456789render() 可以将打开的网页截图并保存成本地图片，可以将指定的图片文件名作为参数传入，render 方法可以根据文件名的后缀将图片保存成对应的格式。目前支持 PNG、GIF、JPEG、PDF 四种图片格式。var webPage = require('webpage');var page = webPage.create();page.viewportSize = &#123; width: 1920, height: 1080 &#125;;page.open(\"http://www.google.com\", function start(status) &#123; page.render('google_home.jpeg', &#123;format: 'jpeg', quality: '100'&#125;); phantom.exit();&#125;); 该方法的第一个参数是保存的文件名，第二个可选参数是一个JSON对象，format指定图片格式，quality指定0-100区间内的图片质量，必须是整数。 onResourceRequested当页面去请求一个资源时，会触发 onResourceRequested() 方法的回调函数。 回调函数接受两个参数，第一个参数 requestData 是这个 HTTP 请求的元数据对象，包括以下属性： 123456789101112131415161718192021id: 所请求资源的 id 号，这个应该是 phantomjs 给标识的。method: 所使用的 HTTP 方法 ( GET/POST/PUT/DELETE 等)。url: 所请求资源的URLtime: 包含请求该资源时间的一个 Date 对象。headers: 该请求的 http 请求头中的信息数组。第二个参数 networkRequest 包含以下方法：abort(): 终止当前的网络请求，这会导致调用 onResourceError 回调函数。changeUrl( newUrl )：改变当前网络请求的 URL。setHeader( key, value )：设置HTTP头信息。var webPage = require( 'webpage' );var page = webPage.create();page.onResourceRequested = function(requestData, networkRequest) &#123; console.log('Request (#' + requestData.id + '): ' + JSON.stringify(requestData));&#125;;page.open(\"http://ke.qq.com\", function(status) &#123; if(status) &#123; console.log(\"fail!\"); &#125; phantom.exit();&#125;);","tags":[{"name":"前端页面自动化测试","slug":"前端页面自动化测试","permalink":"http://yoursite.com/tags/前端页面自动化测试/"}]},{"title":"React","date":"2016-12-10T11:00:41.000Z","path":"2016/12/10/React/","text":"Virtual DOM ·虚拟·React 在每次需要渲染时，会先比较当前 DOM 内容和待渲染内容的差异， 然后再决定如何最优地更新 DOM Props（属性，就是 element 上的 attrs，换个名字 property，变成复数，即 props）State 主要记录状态。 JSX 语法就是 JS 与 HTML 的混写。 关于 HTML 转义React 会将所有要显示到 DOM 的字符串转义，防止 XSS。 所以如果 JSX 中含有转义后的实体字符比如 &copy; (©) 最后显示到 DOM 中不会正确显示，因为 React 自动把 &copy; 中的特殊字符转义了。有几种解决办法： 1 直接使用 UTF-8 字符 © 2 使用对应字符的 Unicode 编码 3 使用数组组装 {[‘cc ‘, &copy;, ‘ 2015’]} 4 直接插入原始的 HTML123&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: 'cc &amp;copy; 2015'&#125;&#125; /&gt;dangerouslySetInnerHTML 参考文档http://reactjs.cn/react/tips/dangerously-set-inner-html.html #### 支持列表 在 jsx 中，并不是所有的标签都支持。 标签查询：http://reactjs.cn/react/docs/tags-and-attributes.html 属性查询：class 属性 — className for 属性 — htmlFor 属性扩散把多个参数一次性放到 HTML 标签中。 1234567891011121314var ps = &#123; p1:'ok1', p2:'ok2', p3:'ok3'&#125;ReactDom.render( &lt;div&gt; &lt;Hello &#123;...ps&#125;&gt;&lt;/Hello&gt; &lt;/div&gt;, document.getElementById('app'), function () &#123; console.log('渲染完了') &#125;) 注释{} 中 可以写 JS 语法 1234567891011ReactDom.render( &lt;div&gt; &#123;/*注释*/&#125; &#123;alert(123)&#125; &lt;Hello &#123;...ps&#125;&gt;&lt;/Hello&gt; &lt;/div&gt;, document.getElementById('app'), function () &#123; console.log('渲染完了') &#125;) 顶层 API生命周期的方法 都在 React.Component 生命周期getDefaultProps 与 getInitialState 在 es6 的写法中不被支持，es6 中，可以在构造函数中使用 this.props 与 this.state componentWillReceiveProps(nextProps) 方法中的 参数 nextProps，表示改变的 props componentDidUpdate ES5 与 ES6箭头函数React.createClass 方法在你的组件上做了一些额外的绑定工作，以确保在组件实例的方法内部， this 指向的是组件实例自身。 由于我们使用 ES6+ 的语法定义类的时候没有采用 React.createClass 的方式，所以，这样看来我们不得不手动来绑定这些方法中 this 的指向。 this 可以在声明时就绑定 箭头函数可以预先传递好参数 onClick={ ()=&gt;f1(this.id) } 表示 将 id 当做参数传递进去，运行的时候再传递 静态属性直接被类调用，实例不可以调用。 12345678910111213class Foo &#123; static defaultProps = &#123; autoPlay: false, maxLoops: 10, &#125;; // 注意这里有分号 static classMethod() &#123; return 'hell1o'; &#125;; static age = 1;&#125;console.log(Foo.classMethod());console.log(Foo.defaultProps);console.log(Foo.age); 初始化 props、state 在构造函数中，使用 this React 书写规范 定义模块 class Life extends Component 导出模块 export default 引入模块 import 默认属性 1234static defaultProps = &#123; autoPlay: false, maxLoops: 10,&#125;; // 注意这里有分号 默认state 12345678constructor(props)&#123; super(props); console.log(\"构造函数\"); // 初始化了我们的 state，这是被推荐的写法 this.state = &#123; props1:\"初始化state\" &#125;;&#125; 定义方法 123456789101112 生命周期的方法 componentWillMount()&#123; console.log(\"componentWillMount\"); &#125; 自定义的方法 click1=()=&gt;&#123; console.log(\"点击了单击事件\"); this.setState(&#123; props1:\"改变state的值\" &#125;) console.log(\"点击了单击事件结束\");&#125; 事件函数的调用方式 1234567891011121314151617181920this.handleMouseOver(\"qqq\") 代表函数的返回值&lt;p onMouseOver=&#123; ()=&gt;this.handleMouseOver(\"qqq\") &#125; onClick=&#123;this.handleClick.bind(this,23,\"dfdf\",function()&#123;&#125;)&#125;&gt; You &#123;text&#125; this. Click to toggle.&lt;/p&gt;onMouseOver 接受的是函数，()=&gt;this.handleMouseOver(\"qqq\") 的意思是，return this.handleMouseOver(\"qqq\") // 返回值的函数正确写法handler=(e)=&gt;&#123; console.log(e.target.value); this.setState(&#123; v:e.target.value &#125;); console.log(this.state.v);&#125;render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;'input1'&#125; type=\"text\" value=&#123;this.state.v&#125; onChange=&#123;this.handler&#125;/&gt; &lt;/div&gt; );&#125; 获取事件对象点击事件有事件处理函数，而鼠标悬浮没有。 123456789101112131415161718192021handleClick=(pm1,pm2,pm3,e)=&gt;&#123; console.log(pm1); console.log(pm2); console.log(pm3); console.log(e); // 有事件对象 this.setState(&#123; liked: !this.state.liked &#125;);&#125;// 用箭头函数去定义自己的方法handleMouseOver=(str,e)=&gt;&#123; console.log(str); console.log(e); // 无事件对象&#125;render() &#123; const text = this.state.liked ? 'like' : 'haven\\'t liked'; // return；里面是要渲染的html页面 return ( &lt;p onMouseOver=&#123;()=&gt;this.handleMouseOver(\"期\")&#125; onClick=&#123;()=&gt;this.handleClick(this,223,\"dfdf\",function()&#123;&#125;)&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; );&#125; 事件移除12345678910componentDidMount() &#123; // 1、在已经插入到真实的dom节点之后，注册窗体改变大小的事件监听 // 2、用 ajax 发起数据请求的操作也要在 componentDidMount 方法里面去调用 window.addEventListener('resize', this.handleResize);&#125;componentWillUnmount() &#123; // 1、在组件将要被卸载的时候移除监听事件，防止对其他组件的影响 window.removeEventListener('resize', this.handleResize);&#125; 获取 DOM 元素通过 refs 与 ref 属性 1234567891011设置元素&lt;input ref=\"theInput1\" value=&#123;this.state.userInput&#125; onChange=&#123;this.handleChange.bind(this)&#125;/&gt;获取元素componentWillMount()&#123; console.log(this.refs.theInput1)&#125; 表单受控表单，使用 onchange 事件控制。 组合组件，循环渲染子组件，渲染子组件的时候，需要加 key={} 属性，提高 虚拟DOM 效率。 props 属性校验12345// 进行属性校验static propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired,&#125;; Context爷爷 不通过 爸爸 直接给 孙子 传递数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 孙子var Button = React.createClass(&#123; // 在孙子里面校验祖宗里面的属性 contextTypes: &#123; color: React.PropTypes.string &#125;, render: function() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.context.age&#125;&lt;/h1&gt; &lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;);// 爹var Message = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;);// 爷爷var MessageList = React.createClass(&#123; // 通过这个方法去传递属性 getChildContext: function() &#123; // 传递给子孙 return &#123; color: \"red\", age:12 &#125;; &#125;, // 传递给子孙属性的类型校验 childContextTypes: &#123; color: React.PropTypes.string, age: React.PropTypes.number &#125;, render: function() &#123; var children = this.props.messages.map(function(message) &#123; return &lt;Message text=&#123;message.text&#125; /&gt;; &#125;); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125;); ES6 写法 123456constructor(props,context)&#123;super(props,context)&#125;static contextTypes=&#123;xx:xx&#125; 动画react-addons-css-transition-group 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// react中的dom监听事件import React, &#123; Component &#125; from 'react';import ReactCSSTransitionGroup from 'react-addons-css-transition-group'import './animate.css'export default class Animate extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;items: ['hello', 'world', 'click', 'me']&#125;; this.handleAdd = this.handleAdd.bind(this); &#125; handleAdd() &#123; const newItems = this.state.items.concat([ prompt('Enter some text') ]); this.setState(&#123;items: newItems&#125;); &#125; handleRemove(i) &#123; let newItems = this.state.items.slice(); newItems.splice(i, 1); this.setState(&#123;items: newItems&#125;); &#125; render() &#123; const items = this.state.items.map((item, i) =&gt; ( &lt;div key=&#123;item&#125; onClick=&#123;() =&gt; this.handleRemove(i)&#125;&gt; &#123;item&#125; &lt;/div&gt; )); return ( &lt;div&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;Add Item1&lt;/button&gt; &#123;/*这个组件虽然叫动画，但是它只负责显示隐藏的动画*/&#125; &#123;/*你想让谁有显示隐藏的动画你就用ReactCSSTransitionGroup包裹谁*/&#125; &#123;/*后添加进去的元素和删除的元素才有动画效果，同时添加元素和ReactCSSTransitionGroup是没有动画效果的*/&#125; &#123;/*transitionName 表示引入 css 文件样式的 前缀（看CSS文件）*/&#125; &#123;/*是否开启 transitionAppear 初始动画*/&#125; &#123;/*component 指定动画元素被哪个元素包裹*/&#125; &#123;/*加上 transitionAppear 会有警告 */&#125; &lt;ReactCSSTransitionGroup component=\"div\" transitionName=\"example\" transitionEnterTimeout=&#123;500&#125; transitionLeaveTimeout=&#123;300&#125;&gt; &#123;items&#125; &lt;/ReactCSSTransitionGroup&gt; &lt;/div&gt; ); &#125;&#125;/*-enter是进入的时候的初始状态*/.example-enter &#123; opacity: 0.01;&#125;/*-enter-active是进入时候的结束状态*/.example-enter.example-enter-active &#123; opacity: 1; transition: opacity 500ms ease-in;&#125;.example-leave &#123; opacity: 1;&#125;.example-leave.example-leave-active &#123; opacity: 0.01; transition: opacity 300ms ease-in;&#125;.example-appear &#123; opacity: 0.01;&#125;.example-appear.example-appear-active &#123; opacity: 1; transition: opacity .5s ease-in;&#125;","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Webpack","date":"2016-12-03T02:00:41.000Z","path":"2016/12/03/Webpack/","text":"参考资料官网：http://webpack.github.io/docs/ Webpack-handlebook: http://zhaoda.net/webpack-handbook/ Gitbook: http://fakefish.github.io/react-webpack-cookbook/index.html Gulp 任务型处理Webpack 也是构建工具，适合处理 SAP，例如 react vue ng2 Webpack 脚本命令12345678910运行wp： webpack --config 配置文件名 默认查找，webpack.config.jswebpack -w 提供 watch 方法，实时进行打包更新webpack -p 对打包后的文件进行压缩webpack -d 提供 SourceMaps，方便调试webpack --colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤webpack --profile 输出性能数据，可以看到每一步的耗时webpack --display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块webpack --display-error-details 方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题 webpack 可以作为 NodeAPI 运行123456var webpack = require('webpack');webpack(&#123;//configuration&#125;, function(err, stats)&#123;&#125;); webpack-dev-server 官方插件基于 Express 框架的开发服务器，包含了 webpack 的所有功能。 功能： 监听文件变化，实时打包 自动刷新 安装： webpack-dev-server –save-dev npm 配置文件，scripts 命令行：12345678&#123; \"scripts\": &#123; \"develop\": \"webpack-dev-server --config webpack.develop.config.js --devtool eval --progress --colors --hot --content-base src\", \"publish\": \"webpack --config webpack.publish.config.js\", \"watch\": \"webpack --config webpack.develop.config.js --watch --hot\" &#125;&#125; 12345--devtool eval 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号--progress 显示合并代码进度--colors -- hot 命令行中显示颜色--content-base 项目根目录，以此目录搭建了一个服务器--host 127.0.0.1 --port 9999 指定端口 与 IP 注意： webpack-dev-server 生成的 bundle.js 文件是在内存中的，并没有实际生成，所以在 html 中，只需要引入根目录即可。 如果服务器目录下已经有 bundle.js，则不会自动刷新，需要删除 自动监听123456entry 改成数组，前两个参数固定写法entry:[ 'webpack/hot/dev-server', 'webpack-dev-server/client?http://localhost:9999', path.resolve(__dirname,'src/js/app.js') // 监听的入口文件] entry 的入口文件引入时，会把此入口文件中引入的文件进行 loader 处理，以此类推形成文件流。 加载器 Loader，预处理操作加载器 Loader – 解析 JSX、ES6 安装 babel-loader babel-core babel-preset-es2015 babel-preset-react --save-dev 配置文件 123456789101112module: &#123; loaders: [ // 转换 JSX、ES6 &#123; test: /\\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: 'babel-loader', // 加载模块 \"babel\" 是 \"babel-loader\" 的缩写 query: &#123; presets: ['es2015', 'react'] // 预设，将 es6、react 转换为 es5 &#125; &#125; ]&#125; 在配置文件中，引入的 xxx-loader 后面的 -loader 可以省略 添加 bable 补丁 1234567&#123; test: /\\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: 'babel',// 加载模块 \"babel\" 是 \"babel-loader\" 的缩写 query: &#123; presets: ['es2015', 'react','stage-0','stage-1','stage-2','stage-3'] &#125;&#125; 另一种写法，创建 .babelrc 文件，将配置项写入此文件（VUE 分开写）把上面配置文件中的 query 写入此文件，注意使用 JSON 语法 12345&#123;\"query\": &#123; \"presets\": [\"es2015\", \"react\"] &#125;&#125; 加载器 Loader – 加载 CSS、在 JSX 中引入 CSS 插件 css-loader 会遍历 CSS 文件，然后找到文件中的 url 表达式进行处理（例如图片处理） style-loader 会把 css 代码插入到页面 style 标签中 配置文件 1234&#123; test: /\\.css$/, // css 文件 loader: 'style-loader!css-loader' // 从右向左执行，先 css 后 style&#125; 加载器 Loader – 加载sass sass-loader 添加配置文件 12345// 处理 scss 文件&#123; test: /\\.scss/, loader: 'style-loader!css-loader!sass-loader'&#125; 加载器 Loader – 图片处理不引入此插件，在 CSS、SASS 文件中使用 url 引入图片时，会报错。 把比较小的图片文件转化为 BASE64，减少 HTTP 请求，只对 CSS 文件引入图片有效，对 HTML 引入图片无效。 url-loader file-loader 现在 url-loader 已经包含了 file-loader 配置文件 1234&#123; test: /\\.(png|jpg)$/, loader: 'url?limit=25000' // 图片小于 2500，会以 base64 方式显示&#125; 加载器 Loader – 字体文件处理 url-loader file-loader 配置文件 1234&#123; test: /\\.(woff|eot|ttf|woff2|svg)$/, loader: 'url?limit=2500' // 文件小于 2500，会嵌入 css 文件，减少网络请求&#125; 开发环境配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 开发环境var path = require('path');// 自动打开浏览器插件var OpenBrowserPlugin = require('open-browser-webpack-plugin');module.exports = &#123; // 单页面 SPA 文件入口，无自动刷新 // entry: \"./src/js/app.js\", // 自动刷新，官方写法 entry:[ 'webpack/hot/dev-server', 'webpack-dev-server/client?http://localhost:9999', path.resolve(__dirname,'src/js/app.js') // 监听的入口文件 ], // 输出文件 output: &#123; path: path.resolve(__dirname,'./dist'), // 输出文件位置 filename: \"bundle.js\" &#125;, // 加载器 module: &#123; // 先检查代码风格 // preLoaders: [ // &#123; test: /\\.js$/, loader: \"eslint-loader\", exclude: /node_modules/ &#125; // ], loaders: [ // 转换 JSX、ES6 &#123; test: /\\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: 'babel-loader', // 加载模块 \"babel\" 是 \"babel-loader\" 的缩写 query: &#123; presets: ['es2015', 'react','stage-0','stage-1','stage-2','stage-3'] // 将 ES6、react 语法转换为 ES5，stage 为 转换 es6 的补丁 &#125; &#125;, // 在 JSX 中，引入 CSS 文件 &#123; test: /\\.css$/, // css 文件 loader: 'style-loader!css-loader' // 从右向左执行，先 css 后 style &#125;, // 处理 scss 文件 &#123; test: /\\.scss/, loader: 'style-loader!css-loader!sass-loader' &#125;, // 处理 css 文件中 url 引入的文件，如果不引入此插件，会报错 &#123; test: /\\.(png|jpg|svg|jpeg)$/, loader: 'url?limit=2500' // 图片小于 2500，会以 base64 方式显示 &#125;, // 字体文件处理 &#123; test: /\\.(woff|eot|ttf|woff2|svg)$/, loader: 'url?limit=2500' // 文件小于 2500，会嵌入 css 文件，减少网络请求 &#125; ] &#125;, plugins: [ new OpenBrowserPlugin(&#123;url: 'http://localhost:9999/', browser: 'chrome'&#125;) ]&#125;; 发布环境配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 发布环境var path = require('path');var webpack = require(\"webpack\");// html 插件var HtmlWebpackPlugin = require(\"html-webpack-plugin\");// 提取 css 文件的插件var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");// 删除文件夹var CleanPlugin = require('clean-webpack-plugin');module.exports = &#123; // 单页面spa的入口文件 entry: &#123; app: path.resolve(__dirname, 'src/js/app.js'), vendors: ['react', 'react-dom'] // 要被抽离的第三方插件 &#125;, // 输出文件 output: &#123; path: path.resolve(__dirname, './dist'), // 输出文件位置 filename: \"bundle.js\" &#125;, module: &#123; // 加载器 loaders: [ // 转换 JSX、ES6 &#123; test: /\\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: 'babel-loader', // 加载模块 \"babel\" 是 \"babel-loader\" 的缩写 query: &#123; presets: ['es2015', 'react','stage-0','stage-1','stage-2','stage-3'] // 预设，将 es6、react 转换为 es5 &#125; &#125;, // 在 JSX 中，引入 CSS 文件 &#123; test: /\\.css$/, // css 文件 // loader: 'style-loader!css-loader' // 从右向左执行，先 css 后 style loader: ExtractTextPlugin.extract(\"style-loader\",\"css-loader\")// 如果同时使用多个加载器中间用！连接，加载器的执行顺序是从右往左 &#125;, // 处理 scss 文件 &#123; test: /\\.scss/, // loader: 'style-loader!css-loader!sass-loader' loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader!sass-loader\") &#125;, // 处理 css 文件中 url 引入的文件，如果不引入此插件，会报错 &#123; test: /\\.(png|jpg|svg|jpeg)$/, loader: 'url?limit=2500&amp;name=images/[name].[ext]' // 输出到 images 文件夹下，[name] 与 [ext] 保持原有文件名与后缀名 &#125;, // 字体文件处理 &#123; test: /\\.(woff|eot|ttf|woff2|svg)$/, loader: 'url?limit=2500&amp;name=fonts/[name].[ext]' // 文件小于 2500，会嵌入 css 文件，减少网络请求 &#125; ] &#125;, // 插件 plugins: [ // 删除文件夹 new CleanPlugin(['dist']), // 分离第三方应用插件,name 属性会自动指向 entry 中 vendros 属性，filename 属性中的文件会自动构建到 output 中的 path 属性下面 new webpack.optimize.CommonsChunkPlugin(&#123;name: 'vendors', filename: 'vendors.js'&#125;), // HTML 处理 new HtmlWebpackPlugin(&#123; template: './src/temp.html', // html 模板 htmlWebpackPlugin: &#123; \"files\": &#123; \"css\": [\"app.css\"], // 在 html 模板中 引入 css \"js\": [\"vendors.js\",\"bundle.js\"] // 在 html 模板中 引入 js &#125; &#125;, minify: &#123; removeComments: true, // 删除注释 collapseWhitespace: true, removeAttributeQuotes: true &#125; &#125;), // 提取 css new ExtractTextPlugin(\"app.css\"), // 压缩 new webpack.optimize.UglifyJsPlugin(&#123; // 取消警告 compress: &#123; warnings: false &#125; &#125;), // 内置插件，自动优化第三方包 new webpack.DefinePlugin(&#123; //去掉react中的警告，react会自己判断 'process.env': &#123; NODE_ENV: '\"production\"' &#125; &#125;) ]&#125;;","tags":[{"name":"自动化构建工具","slug":"自动化构建工具","permalink":"http://yoursite.com/tags/自动化构建工具/"}]},{"title":"Gulp 脚手架","date":"2016-11-09T17:01:00.000Z","path":"2016/11/10/Gulp/","text":"扯淡最近公司项目使用的是 Gulp，之前用过一些，但是该忘的都忘了，自己也懒得去翻以前的笔记，正好博客起了作用（可以鞭策我整理和学习）(●’◡’●) 插件总览12345678910111213141516171819202122232425var gulp = require('gulp');// 编译 LESSvar less = require('gulp-less'); // 压缩 CSSvar cssmin = require('gulp-cssmin'); // 自动添加 webkit 前缀，写代码的时候尽量写全，不要太相信这个插件var autoprefixer = require('gulp-autopreixer');// 重命名文件 var rename = require('gulp-rename'); // 图片压缩var imagemin = require('gulp-imagemin');// JS 压缩 var jsMin = require('gulp-uglify'); // JS 合并var jsConcat = require('gulp-concat'); // HTML 压缩var HTMLMin = require('gulp-htmlmin');// 文件打上版本号，防止浏览器缓存 var rev = require('gulp-rev'); // 替换 HTML 文件中引用的文件，替换为带有版本号的文件var revCollector = require('gulp-rev-collector'); // 将 HTML 中 引入的多个 script 标签，替换成一个（拥有自动合并功能）var useref = require('gulp-useref');// 压缩 var gulpif = require('gulp-if'); 具体使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// LESS 编译gulp.task('less2css',function () &#123; gulp.src('./src/less/*.less') .pipe(less()) // 编译 LESS 为 CSS .pipe(autoprefixer()) // CSS 添加 webkit 前缀 .pipe(cssmin()) // 压缩 CSS 文件 .pipe(rev()) // 给 CSS 文件打版本号 .pipe(gulp.dest('./public/css')) // 输出带有版本号的 CSS 文件 .pipe(rev.manifest()) // 获取版本号与文件的对应关系 .pipe(gulp.dest('./src/rev')); // 对应关系 json 文件输出位置&#125;);// JS 压缩、合并gulp.task('JSMin',function () &#123; gulp.src('./src/js/*.js') .pipe(jsMin()) .pipe(jsConcat('all.js')) .pipe(rev()) .pipe(gulp.dest('./public/js')) .pipe(rev.manifest()) .pipe(gulp.dest('./src/rev'));&#125;);// 文件重命名gulp.task('rename',function () &#123; gulp.src('./index.html') .pipe(rename('demo.html')) .pipe(gulp.dest('./'))&#125;);// 图片压缩// 坑：// 1. 图片在两个目录，需要在一个 src 方法写入两个路径（通过数组传入多个文件）// 2. 处理前文件的不同路径输出到对应文件路径（通过配置项 base 写入共同路径部分，剩余不同部分的路径输出到指定位置）// 3. 层级获取文件（path/**/*，会把 path 下的所有层级目录的所有文件都遍历）gulp.task('imgMin',function () &#123; gulp.src(['./src/imgs/**/*','./src/upload/**/*'],&#123;base:'./src'&#125;) .pipe(imagemin()) .pipe(gulp.dest('./public'));&#125;);// HTML 压缩，配置项比较多，自己查查gulp.task('HTMLMin',function () &#123; gulp.src('./src/*.html') .pipe(HTMLMin(&#123; collapseWhitespace:true, // 合并空白符 removeComments:true, // 删除注释 minifyJS:true // 压缩 HTML 中嵌入的 JS 代码 &#125;)) .pipe(gulp.dest('./public'));&#125;);// 将 HTML 中不带有版本号的引用改成带有版本号gulp.task('revCollector',function () &#123; gulp.src(['./src/rev/*.json','./public/*.html']) // 版本号关系文件 与 将要替换的 html 文件 .pipe(revCollector()) // 替换 html 内的文件名 .pipe(gulp.dest('./public'));&#125;);// 替换成一个 script，HTML 写法固定，会把 JS 文件与 CSS 进行合并// HTML 固定写法/*&lt;!--build:js js/main.min.js --&gt;&lt;script src=\"js/lib/a-library.js\"&gt;&lt;/script&gt;&lt;script src=\"js/lib/another-library.js\"&gt;&lt;/script&gt;&lt;script src=\"js/main.js\"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt;&lt;!--build:css css/all.js --&gt;&lt;script src=\"css/1.css\"&gt;&lt;/script&gt;&lt;script src=\"css/2.css\"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; */gulp.task('useref',function () &#123; gulp.src('./src/*.html') .pipe(useref()) // 会把 JS CSS 合并，并且替换 HTML 文件 .pipe(gulpif('*.js',jsMin())) // 此流中有 CSS JS HTML 文件，假如文件是以 .js 结尾，则调用另一个插件压缩 .pipe(gulpif('*.css',cssmin()))// 假如文件是以 .css 结尾，则调用另一个插件压缩 .pipe(gulp.dest('./src/useref'));&#125;); 任务队列123456789101112131415var gulp = require('gulp');// t1 与 t2 是 default 的启动项依赖，会先执行 t1 与 t2，但是不会等待 t1 t2 结束再执行 def// 换句话就是，优先启动 t1 t2，再启动 def，但是 def 不会等待 t1 t2 执行完毕gulp.task('default',['t1','t2'],function () &#123; console.log('def');&#125;);gulp.task('t1',function () &#123; setTimeout(function () &#123; console.log('t1'); &#125;,2000);&#125;);gulp.task('t2',function () &#123; console.log('t2');&#125;);// t2 def t1 123456789101112131415var gulp = require('gulp');gulp.task('default',['t1','t2'],function () &#123; console.log('def');&#125;);gulp.task('t1',function (cb) &#123; setTimeout(function () &#123; console.log('t1'); cb(); &#125;,2000);&#125;);gulp.task('t2',function (cb) &#123; console.log('t2'); cb();&#125;);// t2 t1 def，cb 是官方提供的方式 队列插件1234567891011121314151617181920// 可以控制任务的执行顺序，但是不能解决异步问题// 不用插件写顺序的时候，需要在每个任务后面写 [ ] 数组，填写依赖关系// 使用插件可以一起写，很方便，直观// 如果想要控制异步，还是需要使用 callback() 与 插件结合var gulp = require('gulp');var gulpSequence = require('gulp-sequence');var del = require('del');gulp.task('default',function () &#123; console.log('def');&#125;);gulp.task('t1',function () &#123; console.log('t1');&#125;);gulp.task('t2',function () &#123; console.log('t2');&#125;);gulp.task('t3',function () &#123; console.log('t3');&#125;);gulp.task('sequence', gulpSequence(['t2','t1'],'t3','default')); cb 与 队列插件 结合使用cb 一般写在异步回调函数内。 关于 cb 自己的理解：就像 JAVA 多线程处理同步的锁一样，只要 task 的回调函数有 cb，这个任务就会在内存中执行，其他任务不会执行，直到 cb( )，才会释放锁，其他的 task 才会继续执行。 12345678910111213141516171819202122232425262728293031323334353637// gulp 的任务是控制执行流程，webpack 的任务是处理复杂引用的依赖var gulp = require('gulp');var del = require('del'); // 删除文件和目录var gulpSequence = require('gulp-sequence'); // 按顺序执行var webpack = require(\"webpack\"); // 引入 webpack 的本地模块// 引入 wbpack 的配置文件，webpackConfig 中有 exportsvar webpackConfig = require(\"./webpack.publish.config.js\");// default 任务gulp.task('default',['sequence'], function() &#123; console.log(\"项目构建成功\");&#125;);// 流程控制gulp.task('sequence', gulpSequence('clean','webpack'));// 删除文件和文件夹gulp.task('clean', function(cb) &#123; //del('dist); // 如果直接给 dist 的目录，项目启动的顺序还有清除结果会报错，所以要写的更详细一些 del(['dist/*.js','dist/*.css','dist/images','dist/*.html']).then(function () &#123; cb(); &#125;);&#125;);// 写一个任务，在 gulp 中执行 webpack 的构建// gulp 负责任务流程部分的操作，webpack 负责复杂模块系统的引用分离工作gulp.task('webpack', function(cb) &#123; // 执行 webpack 的构建任务 webpack(webpackConfig, function (err, stats) &#123; if (err)&#123; console.log(\"构建任务失败\"); &#125;else&#123; cb(); &#125; &#125;);&#125;);","tags":[{"name":"自动化构建工具","slug":"自动化构建工具","permalink":"http://yoursite.com/tags/自动化构建工具/"}]},{"title":"git 常用命令","date":"2016-05-28T18:32:12.000Z","path":"2016/05/29/Github/","text":"SVN 集中式服务器 代码库在集中式服务器中 干完活再推送到中央服务器 分布式 每人的计算机都有自己代码库 实现多人协作 A 人修改 文件1，B 人同事修改 文件1 A 与 B 两人相互推送就可以看到对方的修改。 在实际开发中并不会 A 与 B 直接交换。 通常有一个计算机充当交换的媒介。 git 常用命令 $ pwd #显示当前目录 $ git diff readme.md #查看当前文件修改了什么内容 2.1 $ git status #告诉你有文件被修改过，用 git diff filename 可以查看修改内容 $ git log # 可以查看提交 commit 信息 3.1 $git log –pretty=oneline # 简洁显示 哈希值信息 $ git rest –hard HEAD^ # 回退到上一次提交的状态，通过 git log 查看，本次提交的信息被清除了 $ git rest –hard 版本ID # 回退到指定版本ID $ git reflog # 记录每一次命令 $ git checkout – readme.md # 把工作区的文件回退到最近一次 add 或者 commit 的状态 $ ls -al # 查看当前目录下的所有文件 $ git add -A // add 全部，-A 换成 * 也可以 提交时的用户信息，并不是 github 帐号$ git config –global user.name “yourname” $ git config –global user.email “your_email@example.com” –global 表示在当前机器所有仓库都使用此配置 在计算机用户目录下有 .gitconfig 文件，保存这些信息。 如果不配置用户信息，则无法 commit。 注意 GIT 只能跟踪文本文件的改动，例如 TXT/HTML/…… 视频、图片这些二进制文件无法跟踪改动 Word 文档也是二进制文件，无法跟踪改动 windows 自带笔记本用来保存 UTF-8 文件时，会给每个文件开头默认 添加一个 十六进制 的字符来保存编码格式，建议使用 notepad++ Git 跟踪并管理的是修改，而非文件。 远程仓库SSH 登录SSH 协议：实现计算机间的安全登录。 有专门实现 SSH 协议的软件：openssh 软件，实现了 SSH 协议。 登录命令： ssh 用户名@IP地址 创建服务器裸仓库裸仓库：就是没有工作区的仓库，裸仓库里面的内容就是 .git 文件夹下的文件。 命令：$ git init –bare 本机仓库 push 到服务器，push 指定的分支命令：$ git push 用户名:IP:服务器路径 分支 $ git push leehao:192.168.32.02 master $ password: 服务器克隆到本机$ git clone leehao@192.168.32.02:服务器目录 $ password: 分支分支解释git 默认给我们创建了 master 分支。 命令：$ git branch login # 创建分支 $ git checkout -b login # 创建分支，并且切换分支 创建新的分支时，最好要切换到主分支在进行创建 如果在子分支创建分支，子分支可能有 BUG，然后携带到新的分支。 被创建新的分支后，子分支会继承父分支所有提交的历史。 在子分支下 通过 git log 可以查看到包括父分支下的所有提交记录。 切换分支$ git checkout login # 切换分支后，工作区的代码变成了切换后分支的文件，所以切换分支前，先commit 提交保存。 分支合并$ git merge login # 在当前主分支下 和并 login 分支 删除分支$ branch -d 分支名 查看所有分支$ git branch 处理冲突两个分支合并后，有可能会有冲突，合并后会有提示文件的冲突位置会变成如下格式： &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 冲突代码段 1 =========== 冲突代码段 2 &lt;&lt;&lt;&lt;&lt;&lt;&lt; 分支名字 修改冲突的代码后，commit 即可。 pull 与 clone 的区别共同点都是把远程仓库的代码下载到本地。 不同点 $ git clone 地址，会把 .git 库也下载到本地 $ git push 地址 分支，不会下载 .git 文件夹，需要手动 init 本地目录 git fetch 与 git pull fetch 获取远程最新版本，不会自动 merge pull 从远程获取代码，并自动 merge，相当于 fetch + merge 操作 fetch 更加安全，可以查看文件后再做 Merge 操作","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"HTTP","date":"2015-10-10T02:18:07.000Z","path":"2015/10/10/HTTP/","text":"HTTP 简介HTTPHyperText Transfer Protocol ( 超文本传输协议 )，是工作在 tcp/ip 协议基础上的，所有的 WWW 文件都必须遵守这个标准。设计 HTTP最初的目的是为了提供一种发布和接收 HTML 页面的方法。 特点 HTTP 协议是建立在 TCP/IP 协议基础上 HTTP 协议全称 超文本传输协议 HTTP 协议 1.0 、1.1 版本，目前通用的是 1.1 版本 HTTP 1.0 称为短连接会话结束后，就挂断，HTTP 1.1 称为长连接会话结束后，会保留一段时间，所谓长和短，指的是持续时间的长度。 HTTP 的请求部分基本结构请求行由（请求方式、请求 URL、协议版本构成） 请求行 --------- GET /LoginDemo/LoginServlet HTTP/1.1 请求头 --------- Accept text/html, application/xhtml+xml, */* (空行) 请求体 内容 关于请求体当以 post 形式提交表单的时候，请求头里会设置 Content-Type: application/x-www-form-urlencoded，以 get 形式不需要设置，直接将数据拼接到 URL 即可。 只有 post 请求时，才有请求体。如果有请求体，请求体在回车之后。如果没有请求体，也会有 空行 存在。 详解 HTTP 请求消息头12345678910111213141516171819202122232425261）Accept：text/html,image/* [ 告诉服务器，我可以接收，文本，网页，图片 ] 现在的浏览器已经不需要此字段了，基本都支持所有的数据类型，历史问题2）Accept-Charset：ISO-8859-1 [ 接收字符编码 ISO-8859-1 ]3）Accept-Encoding：gzip,compress [ 可以接收 gzip,compress 压缩后的数据 ] 告诉浏览器我可以接收什么样的压缩格式，节省带宽4）Accept-Language：en-us,zh-cn [ 浏览器支持 中，英文 ]5）Host：www.sohu.com:80 [ 要找的主机是 www.sohu.com:80 ]6）If-Modified-Since：Tue,11 Jul 2000 16:16:16 [ 告诉服务器，我的缓存中有这个资源文件，该文件的时间是....如上.. 如果服务器上的文件有修改，就给我。没修改，就不要给我了。]7）Referer：http://www.sowu.com [ 告诉服务器，我来自哪里。该消息头常用于防止盗链 ]8）User-Agent：Mozilla/4.0(compat...........) [ 告诉服务器，浏览器内核 ]9）Cookie： [ 后续 ]10）Connection：close/Keep-Alive [ 保持连接，发完数据后，我不关闭连接 ]11）Date：Tue，11 Jul....... [ 浏览器发送该 HTTP 请求的时间 ] HTTP 的响应部分1234567基本结构：状态行 ------ HTTP/1.1 200 OK响应消息头 ------ Server：apache tomcat .......省略.......(空行)内容 ------ 状态行格式：HTTP 版本号 状态码 原因叙述 例子：HTTP/1.1 200 OK 状态码是用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为 5 类。 12345678910100~199 表示成功接收请求，要求客户端继续提交 下一次请求才能完成整个处理过程200~299 表示成功接收请求并已完成整个处理过程，常见 200300~399 为完成请求，客户需要进一步细化请求。 例如，请求的资源已经移动一个新地址，常用 302400~499 客户端请求有错误，常见 404500~599 服务器端出现错误，常用 500注：每个范围内的所有数字并不是都有含义，例如 100~199 并不是这个区间的状态码全部存在。 模拟：302 12345response.setStatus(302);response.setHeader(\"Location\",\"/webapp.servlet\");上两行等价于下一行：response.sendRedirect(\"/webapp.servlet\"); 1234567891011121314151617181920212223242526272829303132333435363738响应消息头1）Location：http://www.baidu.com [ 让浏览器重新定位到URL ]2）Server：apache tomcat [ 告诉浏览器，我是 Tomcat ]3）Content-Encoding：gzip [ 告诉浏览器，这个数据是 gzip 压缩数据 ]4）Content-Length：80 [ 告诉浏览器发送的数据大小是 80 字节 ]5）Content-Type：text/html; charset=GB2313 [ 内容格式 text/html; 编码gb2312 ]6）Content-Language：zh-cn [ 支持中文 ]7）Last-Modified：tue,11 jul 2001-2-2 [ 告诉浏览器，该资源上次的更新时间，和缓存比较，如果资源修改了， 及时更新 ]8）Refresh：1；url=http://www.baidu.com [ 过多久，刷新到此 URL 。如果 URL 写自己的页面，就是定时刷新]9）Content-Disposition：attachment；filename=aaa.zip [ 告诉浏览器，有文件要下载 ] 下载的过程： 1. 服务器先读取web应用的资源文件进服务器内存 2. 然后在把数据传输给浏览器客户端10）Transfer-Encoding：chunked [ 传输编码 ]11）SetCookie：ss=Q0; path=/search [ 后续 ]12）Expires：-1 -1 是数字， response.setDateHeader(\"Expires\",-1) ; [ 告诉浏览器，如何缓存页面 ] IE Cache-Control：no-cache response.setHeader(\"Cache-Control\",\"no-cache\"); [ 告诉浏览器，如何缓存页面 ] 其他 Pragma：no-cache response.setHeader(\"Pragma\",\"no-cache\"); [ 告诉浏览器，如何缓存页面 ] 其他13）Connection：close/KeepAlive [ 连接方式，长连接 ]14）Date：tue，11....... [ 传回来的时间 ] 状态码速查表1234567891011121314151617181920212223242526272829303132333435363738100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议200 OK 一切正常，对GET和POST请求的应答文档跟在后面。201 Created 服务器已经创建了文档，Location头给出了它的URL。202 Accepted 已经接受请求，但处理尚未完成。203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝204 No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。302 Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。303 See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取307 Temporary Redirect 和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。400 Bad Request 请求出现语法错误。401 Unauthorized 客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。403 Forbidden 资源不可用。404 Not Found 无法找到指定位置的资源405 Method Not Allowed 请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用。406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权。408 Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。409 Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。410 Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。411 Length Required 服务器不能处理请求，除非客户发送一个Content-Length头412 Precondition Failed 请求头中指定的一些前提条件失败413 Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头414 Request URI Too Long URI太长416 Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求501 Not Implemented 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]}]